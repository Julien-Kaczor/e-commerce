"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@emotion/core");
const emotion_theming_1 = require("emotion-theming");
const merge_1 = __importDefault(require("lodash/merge"));
const React = __importStar(require("react"));
const ErrorBoundary_1 = __importDefault(require("../Internals/ErrorBoundary"));
const Message_1 = __importDefault(require("../Internals/Message/Message"));
const Messages_1 = __importDefault(require("../Internals/Messages/Messages"));
const OperationalContext_1 = require("../OperationalContext/OperationalContext");
const Progress_1 = __importDefault(require("../Progress/Progress"));
const utils_1 = require("../utils");
const constants_1 = __importDefault(require("../utils/constants"));
const styled_1 = __importDefault(require("../utils/styled"));
const baseStylesheet = (theme) => `
* {
  box-sizing: border-box;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  font-smoothing: antialiased;
}

html,
body {
  margin: 0;
  padding: 0;
  font-family: ${theme.font.family.main};
  font-size: 13px;
  height: 100%;
}

body {
  background-color: white;
}

a:link,
a:visited {
  color: ${theme.color.primary};
  text-decoration: none;
}

a:hover: {
  color: ${utils_1.darken(theme.color.primary, 5)};
}

ul, ol {
  margin: 0 0 0 ${theme.space.content}px;
  padding: 0;
}
`;
const Container = styled_1.default("div") `
  position: relative;
  min-height: 60px;
  height: 100%;
`;
const colorByMessageType = (type) => {
    switch (type) {
        case "info":
            return "primary";
        case "success":
            return "success";
        case "error":
            return "error";
    }
};
class OperationalUI extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            messages: [],
            isLoading: false,
        };
        /**
         *  The interval responsible for periodically checking
         *  whether any messages need to be removed from state
         */
        this.messageTimerInterval = null;
        this.setLoading = (isLoading) => {
            this.setState(() => ({ isLoading }));
        };
        this.pushMessage = (message) => {
            const hasSamePayload = (m) => m.message.body === message.body && m.message.type === message.type;
            this.setState(prevState => {
                const hasPreviousMessageWithSamePayload = Boolean(prevState.messages.find(hasSamePayload));
                if (hasPreviousMessageWithSamePayload) {
                    return {
                        messages: prevState.messages.map(m => {
                            if (hasSamePayload(m)) {
                                return Object.assign({}, m, { addedAt: new Date().getTime(), count: m.count + 1 });
                            }
                            else {
                                return m;
                            }
                        }),
                    };
                }
                return {
                    messages: [{ message, addedAt: new Date().getTime(), count: 1 }, ...prevState.messages],
                };
            });
            // If we don't yet have an interval, start one.
            if (!this.messageTimerInterval) {
                this.messageTimerInterval = setInterval(() => this.removeOutdatedMessages(), 2000);
            }
        };
        this.clearMessages = () => {
            this.setState({
                messages: [],
            });
        };
    }
    removeOutdatedMessages() {
        if (this.props.hideMessageAfter === 0) {
            return;
        }
        const now = new Date().getTime();
        const filteredMessages = this.state.messages.filter(({ message, addedAt }) => message.type === "error" || now - addedAt < (this.props.hideMessageAfter || 10000));
        // If we're out of messages, clear the interval.
        if (!filteredMessages.length && this.messageTimerInterval) {
            clearInterval(this.messageTimerInterval);
            this.messageTimerInterval = null;
        }
        // Only run a setState if any message(s) were removed.
        if (this.state.messages.length > filteredMessages.length) {
            this.setState(() => ({ messages: filteredMessages }));
        }
    }
    componentDidCatch(error) {
        this.setState({ error });
        if (this.props.onError) {
            this.props.onError(error);
        }
    }
    componentWillUnmount() {
        if (this.messageTimerInterval) {
            clearInterval(this.messageTimerInterval);
        }
    }
    render() {
        const { pushState, replaceState, children, theme, errorBoundary } = this.props;
        return (React.createElement(emotion_theming_1.ThemeProvider, { theme: merge_1.default(constants_1.default, theme) }, this.state.error && errorBoundary !== false ? (React.createElement(ErrorBoundary_1.default, { error: this.state.error })) : (React.createElement(OperationalContext_1.Provider, { value: {
                pushState,
                replaceState,
                pushMessage: this.pushMessage,
                clearMessages: this.clearMessages,
                loading: this.state.isLoading,
                setLoading: this.setLoading,
            } },
            !this.props.noBaseStyles && React.createElement(core_1.Global, { styles: baseStylesheet(merge_1.default(constants_1.default, theme)) }),
            React.createElement(Container, null,
                this.state.isLoading && React.createElement(Progress_1.default, null),
                React.createElement(Messages_1.default, null, this.state.messages.map(({ message, count }, index) => (React.createElement(Message_1.default, { key: index, color: colorByMessageType(message.type), onClick: message.onClick, onClose: () => this.setState(prevState => ({
                        messages: prevState.messages.filter((_, filteredMessageIndex) => filteredMessageIndex !== index),
                    })) },
                    count > 1 ? `(${count}) ` : "",
                    message.body)))),
                children)))));
    }
}
OperationalUI.defaultProps = {
    theme: {},
    errorBoundary: true,
};
exports.default = OperationalUI;
//# sourceMappingURL=OperationalUI.js.map