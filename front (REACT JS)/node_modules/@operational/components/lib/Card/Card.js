"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const CardItem_1 = __importDefault(require("../CardItem/CardItem"));
const CardHeader_1 = __importDefault(require("../Internals/CardHeader"));
const Tabs_1 = __importDefault(require("../Internals/Tabs"));
const styled_1 = __importDefault(require("../utils/styled"));
// Type guard to check whether we're working with a card with tabs, detecting type correctly afterwards
const isWithTabs = (props) => {
    return props.hasOwnProperty("tabs");
};
const Container = styled_1.default("div")(({ theme }) => ({
    marginBottom: theme.space.element,
    borderTop: `1px solid ${theme.color.separators.light}`,
    boxShadow: theme.shadows.card,
    backgroundColor: theme.color.white,
    wordWrap: "break-word",
    "& > img": {
        maxWidth: "100%",
    },
    /**
     * Since there is no further element to separate this card from, the bottom margin is disabled.
     * This avoids unwanted overflowing behavior especially in cases where there is a single card.
     */
    "&:last-child": {
        marginBottom: 0,
    },
}));
const Content = styled_1.default("div") `
  padding: ${({ theme }) => theme.space.element}px;
  height: ${props => (props.fullSize ? "100%" : "auto")};
  white-space: pre-wrap;
  word-wrap: break-all;
  hyphens: auto;
`;
const TabsBarContainer = styled_1.default("div") `
  display: flex;
  align-items: center;
`;
/**
 * This extra element is necessary to prevent buttons added in the `leftOfTabs` prop to extend
 * to full height.
 */
const TabsBarLeftContainer = styled_1.default("div") `
  margin-right: 32px;
`;
const SectionsContainer = styled_1.default("div") `
  ${({ stackHorizontal, theme }) => `
    display: ${stackHorizontal ? "flex" : "block"};

    /* 
      Assume the first level down is a section
      since this is a SectionsContainer.
    */
    > div { border-right: ${stackHorizontal ? `1px solid ${theme.color.separators.default}` : `none`} };	
  `};
`;
const objectKeys = (x) => Object.keys(x);
/**
 * Render card items corresponding to the specified data.
 */
function renderData(props) {
    const { keyFormatter, valueFormatters = {}, data, keys, sortKeys } = props;
    const _keys = keys ? keys : objectKeys(data || {}).sort(sortKeys);
    const titles = keyFormatter ? _keys.map(keyFormatter) : _keys;
    const values = _keys.map(i => {
        const valueFormatter = valueFormatters[i];
        const value = data ? data[i] : undefined;
        return valueFormatter ? valueFormatter(value) : value;
    });
    return data && titles.map((cardItemTitle, i) => React.createElement(CardItem_1.default, { key: i, value: values[i], title: cardItemTitle }));
}
function Card(props) {
    const { title, keyFormatter, valueFormatters = {}, sections, stackSections, data, keys, children, action, fullSize } = props, rest = __rest(props, ["title", "keyFormatter", "valueFormatters", "sections", "stackSections", "data", "keys", "children", "action", "fullSize"]);
    if (sections) {
        return (React.createElement(Container, Object.assign({}, rest),
            (title || action) && React.createElement(CardHeader_1.default, { title: title, action: action }),
            React.createElement(SectionsContainer, { stackHorizontal: stackSections === "horizontal" }, sections)));
    }
    if (isWithTabs(props)) {
        const { onTabChange } = props, otherProps = __rest(props, ["onTabChange"]);
        return (React.createElement(Tabs_1.default, { tabs: props.tabs, activeTabName: props.activeTabName, onTabChange: onTabChange }, ({ tabsBar, activeChildren }) => (React.createElement(Container, Object.assign({}, otherProps),
            React.createElement(CardHeader_1.default, { title: React.createElement(TabsBarContainer, null,
                    React.createElement(TabsBarLeftContainer, null, props.leftOfTabs),
                    tabsBar), action: props.action }),
            React.createElement(Content, { fullSize: fullSize }, activeChildren)))));
    }
    return (React.createElement(Container, Object.assign({}, rest),
        (title || action) && React.createElement(CardHeader_1.default, { title: title, action: action }),
        React.createElement(Content, { fullSize: fullSize },
            renderData(props),
            children)));
}
exports.default = Card;
//# sourceMappingURL=Card.js.map