"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const noop_1 = __importDefault(require("lodash/noop"));
const react_1 = require("react");
/**
 * Hook version of setInterval.
 * @param {() => void} callback - Callback to be repeatedly excuted over a certain interval.
 * @param {number | null} delay - Interval duration in ms. Pass null to cancel an execution.
 * @param {boolean} immediate - Pass true to execute the callback immediately upon mounting.
 * @see https://overreacted.io/making-setinterval-declarative-with-react-hooks/
 */
function useInterval(callback, delay, immediate) {
    const savedCallback = react_1.useRef(noop_1.default);
    // Remember the latest callback.
    // useEffect has no second argument so it will be executed after each render
    // but we don't want to change this value directly in the body of the render function,
    // because render should be pure function
    // After every render, save the latest callback into our ref.
    react_1.useEffect(() => {
        savedCallback.current = callback;
    });
    react_1.useEffect(() => {
        if (immediate && delay !== null) {
            savedCallback.current();
        }
    }, [immediate]); // when immediate changes, we want to restart the timer
    // Set up the interval.
    react_1.useEffect(() => {
        if (delay === null) {
            return undefined;
        }
        // we can read and call latest callback from inside our interval:
        const id = setInterval(() => savedCallback.current(), delay);
        return () => clearInterval(id);
    }, [delay]); // when delay changes, we want to restart the timer
}
exports.useInterval = useInterval;
exports.default = useInterval;
//# sourceMappingURL=index.js.map