"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const Icon_1 = __importDefault(require("../Icon/Icon"));
const Spinner_1 = __importDefault(require("../Spinner/Spinner"));
const styled_1 = __importDefault(require("../utils/styled"));
exports.tabsBarHeight = 40;
const TabsBar = styled_1.default("div")(({ theme, condensed }) => (Object.assign({ display: "flex", alignItems: "flex-end", height: condensed ? theme.titleHeight : exports.tabsBarHeight, color: "inherit" }, (condensed ? { paddingLeft: theme.space.element } : {}))));
const Tab = styled_1.default("div")(({ theme, active }) => ({
    display: "flex",
    height: "100%",
    alignItems: "center",
    justifyContent: "center",
    color: "currentColor",
    opacity: active ? 1 : 0.8,
    textTransform: "uppercase",
    fontFamily: theme.font.family.main,
    fontSize: theme.font.size.small,
    fontWeight: theme.font.weight.medium,
    padding: `0px ${theme.space.element}px`,
    borderBottom: "2px solid",
    borderBottomColor: active ? "currentColor" : "transparent",
    ":hover": {
        cursor: "pointer",
        opacity: 1,
    },
}));
const getTabIndexByName = (tabs, tabName) => {
    if (tabName) {
        const index = tabs.findIndex(({ name }) => name === tabName);
        return index === -1 ? 0 : index;
    }
    return 0;
};
const Tabs = ({ onTabChange, tabs, activeTabName, condensed, children }) => {
    const activeTabIndex = getTabIndexByName(tabs, activeTabName);
    const [activeTab, setActiveTab] = react_1.useState(activeTabIndex);
    react_1.useEffect(() => {
        setActiveTab(activeTabIndex);
    }, [activeTabIndex]);
    const onTabClick = react_1.useCallback((index) => {
        setActiveTab(index);
        if (onTabChange) {
            onTabChange(tabs[index].name);
        }
    }, [onTabChange, tabs, setActiveTab]);
    // Work around: wrap return in fragment- to prevent type error and not having to change childrens return type
    // https://github.com/Microsoft/TypeScript/issues/21699
    return (react_1.default.createElement(react_1.default.Fragment, null, children({
        tabsBar: (react_1.default.createElement(TabsBar, { condensed: condensed }, tabs
            .filter(({ hidden }) => !hidden)
            .map((tab, index) => (react_1.default.createElement(Tab, { condensed: condensed, key: index, active: activeTab === index, onClick: () => onTabClick(index) },
            tab.loading ? (react_1.default.createElement(Spinner_1.default, { left: true, size: 14 })) : (tab.icon && react_1.default.createElement(Icon_1.default, { name: tab.icon, size: 14, color: tab.iconColor, left: true })),
            tab.name))))),
        activeChildren: tabs[activeTab].children,
    })));
};
exports.default = Tabs;
//# sourceMappingURL=Tabs.js.map