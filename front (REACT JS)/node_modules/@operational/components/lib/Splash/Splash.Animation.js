"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const useInterval_1 = __importDefault(require("../useInterval"));
const styled_1 = __importDefault(require("../utils/styled"));
// Number of squares in the animation grid
const squares = 16;
// Number of animating boxes
const boxes = 50;
// Return integer random between 0 and range - 1, boundaries included
const integerRandom = (range) => {
    return Math.floor(Math.random() * range);
};
// If a coordinate falls out of the (0, n - 1) range,
// bounce it back into the animation frame.
const bounce = (coord) => {
    if (coord < 0) {
        return -coord;
    }
    if (coord > squares - 1) {
        return 2 * (squares - 1) - coord;
    }
    return coord;
};
// css Hack so we dont need to worry about max(window.height,window.width)- Only needed when fullscreen is enabled
// https://spin.atomicobject.com/2015/07/14/css-responsive-square/
const FullScreenWrap = styled_1.default("div")({
    position: "absolute",
    width: "100%",
    ":after": {
        content: "''",
        display: "block",
        paddingBottom: "100%",
    },
});
const Container = styled_1.default("div")({
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate3d(-50%, -50%, 0)",
    width: "100%",
    height: "100%",
});
/// Move highly highly dynamic style out of css-js to prevent uneeded classname generation
const Box = styled_1.default("div")({
    position: "absolute",
    transition: "all 0.5s ease-in-out",
    borderRadius: 6,
    width: `calc(${100 / (squares - 1)}% - 8px)`,
    height: `calc(${100 / (squares - 1)}% - 8px)`,
    backgroundColor: "rgba(255, 255, 255, 0.06)",
});
const initialState = {
    animationStep: 0,
    coordinates: Array.from(Array(boxes), (_, index) => index).map(() => ({
        x: integerRandom(squares),
        y: integerRandom(squares),
    })),
};
const Animation = ({ isFullscreen, size = 600 }) => {
    const [state, updateAnimation] = react_1.useState(initialState);
    useInterval_1.default(() => {
        updateAnimation({
            animationStep: state.animationStep + 1,
            coordinates: state.coordinates.map((coord, index) => {
                if (index % 3 === state.animationStep % 3) {
                    const dx = integerRandom(3) - 1;
                    const dy = integerRandom(3) - 1;
                    return {
                        x: bounce(coord.x + dx),
                        y: bounce(coord.y - dy),
                    };
                }
                return coord;
            }),
        });
    }, 5000, true);
    const children = state.coordinates.map((coord, index) => (react_1.default.createElement(Box, { key: index, style: {
            top: `${(coord.x / (squares - 1)) * 100}%`,
            left: `${(coord.y / (squares - 1)) * 100}%`,
        } })));
    // Only will change if isFullscreen or size changes, a workaround from not having to set outer container width and height to max(window.height, window.width)
    return isFullscreen ? (react_1.default.createElement(FullScreenWrap, null,
        react_1.default.createElement(Container, null, children))) : (react_1.default.createElement(Container, { style: { width: size, height: size } }, children));
};
exports.default = Animation;
//# sourceMappingURL=Splash.Animation.js.map