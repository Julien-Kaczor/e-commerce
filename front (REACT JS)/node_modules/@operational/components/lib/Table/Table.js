"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const ActionMenu_1 = __importDefault(require("../ActionMenu/ActionMenu"));
const Icon_1 = __importDefault(require("../Icon/Icon"));
const Small_1 = __importDefault(require("../Typography/Small"));
const styled_1 = __importDefault(require("../utils/styled"));
const Container = styled_1.default("table")(({ theme, fixedLayout }) => ({
    width: "100%",
    backgroundColor: theme.color.white,
    textAlign: "left",
    borderCollapse: "collapse",
    fontSize: theme.font.size.small,
    fontFamily: theme.font.family.main,
    tableLayout: fixedLayout ? "fixed" : "initial",
}));
const Tr = styled_1.default("tr")(({ hover, theme, clickable }) => (Object.assign({ height: 50 }, (hover
    ? {
        ":hover": {
            backgroundColor: theme.color.background.lighter,
            cursor: clickable ? "pointer" : "default",
        },
    }
    : {}))));
const Thead = styled_1.default("thead") `
  tr {
    height: initial;
  }
`;
const Th = styled_1.default("th")(({ theme, sortable }) => (Object.assign({ position: "relative", borderBottom: `1px solid ${theme.color.separators.default}`, color: theme.color.text.lightest, paddingBottom: theme.space.base, "&:first-child": {
        paddingLeft: theme.space.small,
    }, paddingRight: theme.space.small }, (sortable
    ? {
        ":hover": {
            cursor: "pointer",
            color: theme.color.text.light,
            svg: {
                cursor: "pointer",
                fill: theme.color.text.light,
            },
        },
    }
    : {}))));
const ThContent = styled_1.default("span") `
  display: inline-flex;
  align-items: center;
  height: ${props => props.theme.space.medium}px;
  ${props => props.sorted && `color: ${props.theme.color.text.light};`};
`;
const Td = styled_1.default("td")(({ theme, cellWidth }) => (Object.assign({ verticalAlign: "middle", borderBottom: `1px solid ${theme.color.separators.default}`, color: theme.color.text.default, hyphens: "auto", "&:first-child": {
        paddingLeft: theme.space.small,
    }, paddingRight: theme.space.small }, (cellWidth
    ? {
        width: cellWidth,
        wordBreak: "break-all",
        wordWrap: "break-word",
    }
    : {}))));
const Actions = styled_1.default(Td)(({ theme }) => ({
    textAlign: "right",
    paddingRight: theme.space.small,
    /**
     * We use opacity here instead of display: none; or
     * visibility: hidden; because both mess with
     * the box model of the Td while opacity does not.
     */
    opacity: 0,
    "tr:hover &, :hover": {
        opacity: 1,
    },
    "& > div": {
        display: "inline-flex",
    },
}));
const SortIcon = styled_1.default(Icon_1.default) `
  margin-left: ${props => props.theme.space.small}px;
`;
const IconCell = styled_1.default(Td) `
  width: 40px;
  padding: ${props => props.theme.space.base}px;
  color: ${props => props.theme.color.text.lightest};
`;
const ActionLabel = styled_1.default(Small_1.default) `
  color: ${props => props.theme.color.primary};
  margin: 0;
  display: block;
`;
const EmptyView = styled_1.default(Td)(({ theme }) => ({
    color: theme.color.text.default,
    height: 50,
    lineHeight: "50px",
    textAlign: "center",
}));
function Table(_a) {
    var { data = [], columns, onRowClick, rowActionName, rowActions, icon, iconColor, headless, fixedLayout } = _a, props = __rest(_a, ["data", "columns", "onRowClick", "rowActionName", "rowActions", "icon", "iconColor", "headless", "fixedLayout"]);
    const standardizedColumns = columns.map(column => {
        if (typeof column === "string") {
            return {
                heading: column,
                cell: (dataEntry) => dataEntry[column],
            };
        }
        else {
            return column;
        }
    });
    const hasIcons = Boolean(data[0]) && Boolean(icon) && Boolean(icon(data[0]));
    return (React.createElement(Container, Object.assign({ fixedLayout: fixedLayout }, props),
        !headless && (React.createElement(Thead, null,
            React.createElement(Tr, null,
                hasIcons && React.createElement(Th, { key: "-1" }),
                standardizedColumns.map((column, columnIndex) => (React.createElement(Th, { key: columnIndex, sortable: Boolean(column.onSortClick), onClick: () => column.onSortClick && column.onSortClick(column.sortOrder === "desc" ? "asc" : "desc") },
                    React.createElement(ThContent, { sorted: Boolean(column.sortOrder) },
                        column.heading,
                        column.onSortClick && !column.sortOrder && (React.createElement(SortIcon, { size: 10, color: "color.border.disabled", name: "ChevronUpDown" })),
                        column.sortOrder && (React.createElement(SortIcon, { size: 10, color: "primary", name: column.sortOrder === "desc" ? "ChevronUp" : "ChevronDown" })))))),
                Boolean(rowActions || (onRowClick && rowActionName)) && React.createElement(Th, { key: "infinity" })))),
        React.createElement("tbody", null, data.length ? (data.map((dataEntry, dataEntryIndex) => {
            const rowAction = (() => {
                if (!rowActions) {
                    return null;
                }
                const dataEntryRowActions = rowActions(dataEntry);
                return (React.createElement(Actions, null, Array.isArray(dataEntryRowActions) ? (React.createElement(ActionMenu_1.default, { stickyTitle: true, items: dataEntryRowActions })) : (dataEntryRowActions)));
            })();
            return (React.createElement(Tr, { hover: Boolean(onRowClick), key: dataEntryIndex, clickable: Boolean(onRowClick), onClick: () => {
                    if (onRowClick) {
                        onRowClick(dataEntry, dataEntryIndex);
                    }
                } },
                hasIcons && (React.createElement(IconCell, null,
                    React.createElement(Icon_1.default, { name: icon(dataEntry), color: iconColor && iconColor(dataEntry) }))),
                standardizedColumns.map((column, columnIndex) => (React.createElement(Td, { cellWidth: column.width, key: columnIndex }, column.cell(dataEntry, dataEntryIndex)))),
                rowAction,
                onRowClick && rowActionName && (React.createElement(Actions, null,
                    React.createElement(ActionLabel, null, rowActionName)))));
        })) : (React.createElement(Tr, null,
            React.createElement(EmptyView, { colSpan: columns.length }, "There are no records available"))))));
}
exports.default = Table;
//# sourceMappingURL=Table.js.map