{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tinycolor2_1 = __importDefault(require(\"tinycolor2\"));\n\nexports.isWhite = color => [\"white\", \"#fff\", \"#ffffff\", \"hsl(0, 0%, 100%)\"].indexOf(color.toLowerCase()) > -1; // Maps strings deterministally to the same color. Avoids similar strings ending up with the same color.\n\n\nexports.colorMapper = colors => {\n  return str => colors[hash32FNV1aUTF(String(str)) % colors.length];\n};\n/*\n * Hashing algorithm used to pair strings with colors (see `colorMapper` above), chosen\n * as a compromise between speed and low risk of having identical colors assigned for two\n * strings that are nearly identical.\n *\n * Copied from https://github.com/tjwebb/fnv-plus (MIT licensed), author Travis Webb <me@traviswebb.com>\n * This FNV-1a hash algorithm, often simply called \"fnv\", disperses hashes throughout\n * the 32-bit hash space with very good dispersion and is very fast.\n */\n\n/* tslint:disable:no-bitwise */\n\n\nfunction hash32FNV1aUTF(str) {\n  let c;\n  let i;\n  const l = str.length;\n  let t0 = 0;\n  let v0 = 0x9dc5;\n  let t1 = 0;\n  let v1 = 0x811c;\n\n  for (i = 0; i < l; i = i + 1) {\n    c = str.charCodeAt(i);\n\n    if (c < 128) {\n      v0 ^= c;\n    } else if (c < 2048) {\n      v0 ^= c >> 6 | 192;\n      t0 = v0 * 403;\n      t1 = v1 * 403;\n      t1 += v0 << 8;\n      v1 = t1 + (t0 >>> 16) & 65535;\n      v0 = t0 & 65535;\n      v0 ^= c & 63 | 128;\n    } else if ((c & 64512) === 55296 && i + 1 < l && (str.charCodeAt(i + 1) & 64512) === 56320) {\n      i = i + 1;\n      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(i) & 1023);\n      v0 ^= c >> 18 | 240;\n      t0 = v0 * 403;\n      t1 = v1 * 403;\n      t1 += v0 << 8;\n      v1 = t1 + (t0 >>> 16) & 65535;\n      v0 = t0 & 65535;\n      v0 ^= c >> 12 & 63 | 128;\n      t0 = v0 * 403;\n      t1 = v1 * 403;\n      t1 += v0 << 8;\n      v1 = t1 + (t0 >>> 16) & 65535;\n      v0 = t0 & 65535;\n      v0 ^= c >> 6 & 63 | 128;\n      t0 = v0 * 403;\n      t1 = v1 * 403;\n      t1 += v0 << 8;\n      v1 = t1 + (t0 >>> 16) & 65535;\n      v0 = t0 & 65535;\n      v0 ^= c & 63 | 128;\n    } else {\n      v0 ^= c >> 12 | 224;\n      t0 = v0 * 403;\n      t1 = v1 * 403;\n      t1 += v0 << 8;\n      v1 = t1 + (t0 >>> 16) & 65535;\n      v0 = t0 & 65535;\n      v0 ^= c >> 6 & 63 | 128;\n      t0 = v0 * 403;\n      t1 = v1 * 403;\n      t1 += v0 << 8;\n      v1 = t1 + (t0 >>> 16) & 65535;\n      v0 = t0 & 65535;\n      v0 ^= c & 63 | 128;\n    }\n\n    t0 = v0 * 403;\n    t1 = v1 * 403;\n    t1 += v0 << 8;\n    v1 = t1 + (t0 >>> 16) & 65535;\n    v0 = t0 & 65535;\n  }\n\n  return (v1 << 16 >>> 0) + v0;\n}\n\nconst getBrightestColor = colors => colors.reduce((acc, curr) => {\n  if (curr.l > acc.l) {\n    return curr;\n  }\n\n  return acc;\n});\n\nexports.readableTextColor = (backgroundColor, workingColors) => {\n  const backgroundHsl = tinycolor2_1.default(backgroundColor).toHsl();\n  const workingColorHsls = workingColors.map(color => tinycolor2_1.default(color).toHsl());\n\n  if (backgroundHsl.a < 0.5) {\n    return \"#FFFFFF\";\n  } // For reasonably saturated colors on the bright side, still pick the lightest color.\n\n\n  if (backgroundHsl.s > 0.4 && backgroundHsl.l < 0.75) {\n    return tinycolor2_1.default(getBrightestColor(workingColorHsls)).toHexString();\n  }\n\n  return tinycolor2_1.default.mostReadable(backgroundColor, workingColors).toHexString();\n};\n\nexports.darken = (color, percentage) => tinycolor2_1.default(color).darken(percentage).toString();\n\nexports.lighten = (color, percentage) => tinycolor2_1.default(color).lighten(percentage).toString();\n\nexports.getBrightness = color => {\n  const c = tinycolor2_1.default(color);\n  return c.getBrightness();\n};\n\nexports.setBrightness = (color, targetBrightness) => {\n  const c = tinycolor2_1.default(color);\n  const brightness = c.getBrightness();\n  return c.brighten(targetBrightness / brightness * 100 - 100).toString();\n};\n\nexports.setAlpha = amount => color => tinycolor2_1.default(color).setAlpha(amount).toString();","map":null,"metadata":{},"sourceType":"script"}