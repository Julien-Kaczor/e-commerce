{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst noop_1 = __importDefault(require(\"lodash/noop\"));\n\nconst react_1 = require(\"react\");\n/**\n * Hook version of setInterval.\n * @param {() => void} callback - Callback to be repeatedly excuted over a certain interval.\n * @param {number | null} delay - Interval duration in ms. Pass null to cancel an execution.\n * @param {boolean} immediate - Pass true to execute the callback immediately upon mounting.\n * @see https://overreacted.io/making-setinterval-declarative-with-react-hooks/\n */\n\n\nfunction useInterval(callback, delay, immediate) {\n  const savedCallback = react_1.useRef(noop_1.default); // Remember the latest callback.\n  // useEffect has no second argument so it will be executed after each render\n  // but we don't want to change this value directly in the body of the render function,\n  // because render should be pure function\n  // After every render, save the latest callback into our ref.\n\n  react_1.useEffect(() => {\n    savedCallback.current = callback;\n  });\n  react_1.useEffect(() => {\n    if (immediate && delay !== null) {\n      savedCallback.current();\n    }\n  }, [immediate]); // when immediate changes, we want to restart the timer\n  // Set up the interval.\n\n  react_1.useEffect(() => {\n    if (delay === null) {\n      return undefined;\n    } // we can read and call latest callback from inside our interval:\n\n\n    const id = setInterval(() => savedCallback.current(), delay);\n    return () => clearInterval(id);\n  }, [delay]); // when delay changes, we want to restart the timer\n}\n\nexports.useInterval = useInterval;\nexports.default = useInterval;","map":null,"metadata":{},"sourceType":"script"}